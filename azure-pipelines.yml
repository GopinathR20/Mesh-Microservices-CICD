# ==========================================================
# Azure Pipeline - Mesh Microservices (3 Stages)
# Terraform + Docker + WebApp Deploy
# ==========================================================

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - 'Mesh-Microservices/*'
      - 'pom.xml'
      - 'infrastructure/*'

variables:
  # === GLOBAL VARIABLES ===
  azureServiceConnection: 'Azure-Connection'        # Federated Azure connection
  acrServiceConnection: 'ACR-Connection'            # ACR/Docker Registry service connection
  location: 'centralindia'
  resourceGroup: 'mesh-project-rg'
  acrName: 'meshregistry6a333'                      # From Terraform output (static name)
  microservice_list: 'api-gateway,admin-service,classroom-service,discovery-server,user-service,ai-service'
  java_service_list: 'api-gateway,admin-service,classroom-service,discovery-server,user-service'
  docker_tag: '$(Build.BuildId)'
  vmImage: 'ubuntu-latest'
  terraformVersion: '1.6.0'

stages:
  # ==========================================================
  # 1Ô∏è‚É£ Stage: Terraform Infrastructure (Federated Auth)
  # ==========================================================
  - stage: Infra
    displayName: '1. Provision Infrastructure (Terraform)'
    jobs:
      - job: TerraformApply
        displayName: 'Terraform Init & Apply (Federated Auth)'
        pool:
          vmImage: $(vmImage)
        steps:
          - checkout: self

          - task: Bash@3
            displayName: 'Install Terraform $(terraformVersion)'
            inputs:
              targetType: 'inline'
              script: |
                set -euo pipefail
                sudo apt-get update -y && sudo apt-get install -y unzip
                wget -q "https://releases.hashicorp.com/terraform/${terraformVersion}/terraform_${terraformVersion}_linux_amd64.zip" -O terraform.zip
                unzip -o terraform.zip
                sudo mv terraform /usr/local/bin/
                terraform --version

          - task: AzureCLI@2
            name: setOutputs
            displayName: 'Terraform Init & Apply using Federated Identity'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: bash
              scriptLocation: inlineScript
              workingDirectory: 'infrastructure'
              inlineScript: |
                set -euo pipefail

                echo "‚úÖ Using federated authentication context from Azure DevOps..."
                export ARM_USE_OIDC=true
                export ARM_CLIENT_ID=$(servicePrincipalId)
                export ARM_TENANT_ID=$(tenantId)
                export ARM_SUBSCRIPTION_ID=$(subscriptionId)

                echo "Initializing Terraform backend..."
                terraform init -input=false -upgrade \
                  -backend-config="storage_account_name=csg100320035b718cb1" \
                  -backend-config="container_name=tfstate" \
                  -backend-config="key=mesh.prod.terraform.tfstate" \
                  -backend-config="resource_group_name=cloud-shell-storage-centralindia"

                echo "Applying Terraform..."
                terraform apply -auto-approve -input=false

                echo "Setting Terraform output variables..."
                echo "##vso[task.setvariable variable=RG_NAME;isOutput=true]$(terraform output -raw resource_group_name)"
                echo "##vso[task.setvariable variable=ACR_LOGIN_SERVER;isOutput=true]$(terraform output -raw acr_login_server)"
                echo "##vso[task.setvariable variable=ACR_ADMIN_USER;isOutput=true]$(terraform output -raw acr_admin_username)"
                echo "##vso[task.setvariable variable=ACR_ADMIN_PASS;isOutput=true]$(terraform output -raw acr_admin_password)"
                echo "##vso[task.setvariable variable=COSMOS_DB_CONN_STRING;isOutput=true]$(terraform output -raw cosmos_db_connection_string)"

  # ==========================================================
  # 2Ô∏è‚É£ Stage: Build & Push Docker Images
  # ==========================================================
  - stage: Build
    displayName: '2. Build & Push Docker Images'
    dependsOn: Infra
    condition: succeeded('Infra')
    jobs:
      - job: BuildAndPush
        displayName: 'Build & Push All Services'
        pool:
          vmImage: $(vmImage)
        steps:
          - checkout: self

          - task: Maven@3
            displayName: 'Build All Java Modules'
            inputs:
              mavenPomFile: 'pom.xml'
              goals: 'package'
              options: '-DskipTests'
              jdkVersionOption: '1.17'
              jdkArchitectureOption: 'x64'

          - ${{ each service in split(variables.microservice_list, ',') }}:
              - task: Docker@2
                displayName: 'Build & Push: ${{ service }}'
                inputs:
                  command: 'buildAndPush'
                  containerRegistry: $(acrServiceConnection)
                  repository: '${{ service }}'
                  dockerfile: 'Mesh-Microservices/${{ service }}/Dockerfile'
                  buildContext: 'Mesh-Microservices/${{ service }}'
                  tags: |
                    $(docker_tag)
                    latest

  # ==========================================================
  # 3Ô∏è‚É£ Stage: Deploy Containers to WebApps
  # ==========================================================
  - stage: Deploy
    displayName: '3. Deploy Containers to WebApps'
    dependsOn:
      - Infra
      - Build
    condition: succeeded('Build')
    jobs:
      - job: DeployJob
        displayName: 'Deploy All Microservices'
        pool:
          vmImage: $(vmImage)
        variables:
          RG_NAME: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.RG_NAME'] ]
          ACR_LOGIN_SERVER: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.ACR_LOGIN_SERVER'] ]
          ACR_ADMIN_USER: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.ACR_ADMIN_USER'] ]
          ACR_ADMIN_PASS: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.ACR_ADMIN_PASS'] ]
          COSMOS_DB_CONN_STRING: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.COSMOS_DB_CONN_STRING'] ]
        steps:
          - ${{ each service in split(variables.microservice_list, ',') }}:
              - task: AzureCLI@2
                displayName: 'Deploy: ${{ service }}'
                inputs:
                  azureSubscription: $(azureServiceConnection)
                  scriptType: bash
                  scriptLocation: inlineScript
                  inlineScript: |
                    set -euo pipefail
                    APP_NAME="${{ service }}-webapp"
                    IMAGE_NAME="$(ACR_LOGIN_SERVER)/${{ service }}:$(docker_tag)"

                    echo "üöÄ Deploying $APP_NAME with image $IMAGE_NAME"

                    az webapp config container set \
                      --name "$APP_NAME" \
                      --resource-group "$(RG_NAME)" \
                      --docker-custom-image-name "$IMAGE_NAME" \
                      --docker-registry-server-url "https://$(ACR_LOGIN_SERVER)" \
                      --docker-registry-server-user "$(ACR_ADMIN_USER)" \
                      --docker-registry-server-password "$(ACR_ADMIN_PASS)"

                    echo "üîß Updating App Settings for $APP_NAME"
                    SETTINGS=(
                      "WEBSITES_PORT=8080"
                      "SPRING_DATA_MONGODB_URI=$(COSMOS_DB_CONN_STRING)"
                    )

                    if [ "${{ service }}" != "discovery-server" ]; then
                      SETTINGS+=("EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://discovery-server-webapp.azurewebsites.net/eureka/")
                    else
                      SETTINGS+=("EUREKA_CLIENT_REGISTERWITHEUREKA=false" "EUREKA_CLIENT_FETCHREGISTRY=false")
                    fi

                    if [ "${{ service }}" == "ai-service" ]; then
                      SETTINGS+=("GEMINI_API_KEY=$(GEMINI_API_KEY)")
                    fi

                    az webapp config appsettings set \
                      --resource-group "$(RG_NAME)" \
                      --name "$APP_NAME" \
                      --settings "${SETTINGS[@]}"
