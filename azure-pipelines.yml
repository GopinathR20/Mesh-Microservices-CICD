# azure-pipelines.yml (Root Level - 3 Stage)

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - 'Mesh-Microservices/*' # Trigger on code change
      - 'pom.xml'            # Trigger on parent pom change
      - 'infrastructure/*'     # Trigger on terraform change

variables:
  # === YOUR VARIABLES ===
  azureServiceConnection: 'Azure-ARM-Manual' # Your verified ARM connection
  acrServiceConnection: 'ACR-Connection'     # Your ACR/Docker Registry connection
  location: 'centralindia'

  # List must match your 'variables.tf' file and folder names
  microservice_list: 'api-gateway,admin-service,classroom-service,discovery-server,user-service,ai-service'

  # List of services to build with Maven (all except Python-based ai-service)
  java_service_list: 'api-gateway,admin-service,classroom-service,discovery-server,user-service'

  docker_tag: '$(Build.BuildId)'
  vmImage: 'ubuntu-latest'
  terraformVersion: '1.6.0'

stages:
  # ==========================================================
  # Stage 1: Provision Infrastructure (Terraform)
  # ==========================================================
  - stage: Infra
    displayName: '1. Provision Infrastructure'
    jobs:
      - job: TerraformApply
        displayName: 'Terraform Init & Apply'
        pool:
          vmImage: $(vmImage)
        steps:
          - checkout: self

          - task: Bash@3
            displayName: 'Install Terraform $(terraformVersion)'
            inputs:
              targetType: 'inline'
              script: |
                set -euo pipefail
                echo "Installing unzip..."
                sudo apt-get update -y
                sudo apt-get install -y unzip
                
                TFV=$(terraformVersion)
                echo "Downloading terraform ${TFV}..."
                cd /tmp
                wget -q "https://releases.hashicorp.com/terraform/${TFV}/terraform_${TFV}_linux_amd64.zip" -O terraform.zip
                unzip -o terraform.zip
                sudo mv terraform /usr/local/bin/terraform
                terraform --version

          - task: AzureCLI@2
            name: setOutputs
            displayName: 'Terraform Init, Plan, & Apply'
            inputs:
              azureSubscription: $(azureServiceConnection)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              workingDirectory: 'infrastructure' # Run in the infra folder
              inlineScript: |
                set -euo pipefail
                
                echo "terraform init"
                # This init command assumes you created the backend storage account manually
                terraform init -input=false -upgrade \
                  -backend-config="storage_account_name=csg100320035b718cb1" \
                  -backend-config="container_name=tfstate" \
                  -backend-config="key=mesh.prod.terraform.tfstate" \
                  -backend-config="resource_group_name=cloud-shell-storage-centralindia"
                
                # Create the list of services for Terraform
                MS_LIST_STR="$(microservice_list)"
                TF_LIST_VAR="[\"${MS_LIST_STR//,/\",\"}\"]"
                echo "Formatted microservice list for Terraform: ${TF_LIST_VAR}"
                
                echo "terraform plan"
                # Note: We are using a static prefix here for simplicity
                # If you add 'name_prefix' back to variables.tf, you can use it here
                terraform plan -input=false -out=tfplan \
                  -var="location=$(location)" \
                  -var="microservices=${TF_LIST_VAR}"
                
                echo "terraform apply"
                terraform apply -input=false -auto-approve tfplan
                
                echo "Gathering Terraform outputs..."
                # Get all outputs from Terraform for the next stages
                echo "##vso[task.setvariable variable=TF_RG;isOutput=true]$(terraform output -raw resource_group_name)"
                echo "##vso[task.setvariable variable=TF_ACR_NAME;isOutput=true]$(terraform output -raw acr_name)"
                echo "##vso[task.setvariable variable=TF_ACR_LOGIN;isOutput=true]$(terraform output -raw acr_login_server)"
                echo "##vso[task.setvariable variable=TF_COSMOS_CONN_STRING;isOutput=true]$(terraform output -raw cosmos_db_connection_string)"
                echo "##vso[task.setvariable variable=TF_ACR_USER;isOutput=true]$(terraform output -raw acr_admin_username)"
                echo "##vso[task.setvariable variable=TF_ACR_PASS;isOutput=true]$(terraform output -raw acr_admin_password)"

            # This env block is CRITICAL for Terraform to authenticate
            env:
              ARM_CLIENT_ID: $(servicePrincipalId)
              ARM_CLIENT_SECRET: $(servicePrincipalKey)
              ARM_SUBSCRIPTION_ID: $(subscriptionId)
              ARM_TENANT_ID: $(tenantId)

  # ==========================================================
  # Stage 2: Build & Push All Docker Images
  # ==========================================================
  - stage: Build
    displayName: '2. Build & Push Docker Images'
    dependsOn: Infra
    condition: succeeded('Infra')
    jobs:
      - job: BuildAndPush
        displayName: 'Build & Push All Services'
        pool:
          vmImage: $(vmImage)
        variables:
          # Get ACR login server from previous stage
          TF_ACR_LOGIN: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.TF_ACR_LOGIN'] ]
        steps:
          - checkout: self

          # Step 1: Build ALL Java JARs using Parent POM
          - task: Maven@3
            displayName: 'Build All Java Modules (Maven)'
            inputs:
              mavenPomFile: 'pom.xml' # Point to the ROOT pom.xml
              goals: 'package'
              options: '-DskipTests'
              jdkVersionOption: '1.17'
              jdkArchitectureOption: 'x64'

          # Step 2: Build and Push Docker Image for EACH service
          - ${{ each service in split(variables.microservice_list, ',') }}:
              - task: Docker@2
                displayName: 'Build & Push: ${{ service }}'
                inputs:
                  command: 'buildAndPush'
                  containerRegistry: $(acrServiceConnection)
                  repository: '${{ service }}' # Image name, e.g., 'user-service'
                  # Correct path into Mesh-Microservices folder
                  dockerfile: 'Mesh-Microservices/${{ service }}/Dockerfile'
                  buildContext: 'Mesh-Microservices/${{ service }}'
                  tags: |
                    $(docker_tag)
                    latest

  # ==========================================================
  # Stage 3: Deploy ALL Containers to WebApps
  # ==========================================================
  - stage: Deploy
    displayName: '3. Deploy Containers to WebApps'
    dependsOn:
      - Build
      - Infra
    condition: succeeded('Build')
    jobs:
      - job: DeployJob
        displayName: 'Deploy All Services'
        pool:
          vmImage: $(vmImage)
        variables:
          # Get all output variables from the Terraform stage
          RG_NAME: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.TF_RG'] ]
          ACR_LOGIN_SERVER: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.TF_ACR_LOGIN'] ]
          ACR_ADMIN_USER: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.TF_ACR_ADMIN_USER'] ]
          ACR_ADMIN_PASS: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.TF_ACR_ADMIN_PASS'] ]
          COSMOS_DB_CONN_STRING: $[ stageDependencies.Infra.TerraformApply.outputs['setOutputs.TF_COSMOS_CONN_STRING'] ]
        steps:
          # Loop through each service and deploy it
          - ${{ each service in split(variables.microservice_list, ',') }}:
              - task: AzureCLI@2
                displayName: 'Deploy: ${{ service }}'
                inputs:
                  azureSubscription: $(azureServiceConnection)
                  scriptType: 'bash'
                  scriptLocation: 'inlineScript'
                  inlineScript: |
                    set -euo pipefail
                    APP_NAME="${{ service }}-webapp"
                    IMAGE_NAME="$(ACR_LOGIN_SERVER)/${{ service }}:$(docker_tag)"
                    
                    echo "Updating Container Image for $APP_NAME..."
                    az webapp config container set \
                      --name $APP_NAME \
                      --resource-group $(RG_NAME) \
                      --docker-custom-image-name $IMAGE_NAME \
                      --docker-registry-server-url https://$(ACR_LOGIN_SERVER) \
                      --docker-registry-server-user $(ACR_ADMIN_USER) \
                      --docker-registry-server-password $(ACR_ADMIN_PASS)
                    
                    echo "Updating App Settings for $APP_NAME..."
                    # Base settings for all apps
                    SETTINGS=(
                      "WEBSITES_PORT=8080"
                      "SPRING_DATA_MONGODB_URI=$(COSMOS_DB_CONN_STRING)" 
                    )
                    
                    # Add Eureka URL for all services except discovery-server itself
                    if [ "${{ service }}" != "discovery-server" ]; then
                      SETTINGS+=("EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://discovery-server-webapp.azurewebsites.net/eureka/")
                    else
                      SETTINGS+=("EUREKA_CLIENT_REGISTERWITHEUREKA=false" "EUREKA_CLIENT_FETCHREGISTRY=false")
                    fi
                    
                    # Add AI service specific settings
                    if [ "${{ service }}" == "ai-service" ]; then
                      # Assumes GEMINI_API_KEY is in a Variable Group linked to the pipeline
                      SETTINGS+=("GEMINI_API_KEY=$(GEMINI_API_KEY)") 
                    fi
                    
                    # Add settings to Web App
                    az webapp config appsettings set \
                      --resource-group $(RG_NAME) \
                      --name $APP_NAME \
                      --settings "${SETTINGS[@]}"