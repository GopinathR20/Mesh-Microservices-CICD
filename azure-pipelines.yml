# ==========================================================
# Azure Pipeline - Mesh Microservices (3 Stages)
# Terraform + Docker + WebApp Deploy (Service Principal Auth)
# ==========================================================

trigger:
  branches:
    include:
      - main
  paths:
    include:
      - 'Mesh-Microservices/*'
      - 'pom.xml'
      - 'infrastructure/*'

# ----------------------------------------------------------
# Global Variables + Linked Secrets
# ----------------------------------------------------------
variables:
  - group: TerraformSecrets     # Contains ARM_*, GEMINI_API_KEY, etc.
  azureServiceConnection: 'Azure-Connection'
  acrServiceConnection: 'ACR-Connection'
  location: 'centralindia'
  resourceGroup: 'mesh-project-rg'
  acrName: 'meshregistry6a333'
  microservice_list: 'api-gateway,admin-service,classroom-service,discovery-server,user-service,ai-service'
  docker_tag: '$(Build.BuildId)'
  vmImage: 'ubuntu-latest'
  TF_VERSION: '1.6.0'

# ==========================================================
# 1Ô∏è‚É£ Stage: Terraform Infrastructure
# ==========================================================
stages:
  - stage: Infra
    displayName: '1. Provision Infrastructure (Terraform)'
    jobs:
      - job: TerraformApply
        displayName: 'Terraform Init & Apply'
        pool:
          vmImage: $(vmImage)
        steps:
          - checkout: self

          - task: Bash@3
            displayName: 'Install Terraform $(TF_VERSION)'
            inputs:
              targetType: 'inline'
              script: |
                set -e
                echo "Installing Terraform version ${TF_VERSION}"
                sudo apt-get update -y && sudo apt-get install -y unzip wget
                wget -q "https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip" -O terraform.zip
                unzip -o terraform.zip
                sudo mv terraform /usr/local/bin/
                terraform version

          - task: Bash@3
            displayName: 'Terraform Init & Apply'
            inputs:
              targetType: 'inline'
              script: |
                set -e
                cd infrastructure
                echo "‚úÖ Setting Service Principal environment for Terraform..."
                export ARM_CLIENT_ID=$(ARM_CLIENT_ID)
                export ARM_CLIENT_SECRET=$(ARM_CLIENT_SECRET)
                export ARM_TENANT_ID=$(ARM_TENANT_ID)
                export ARM_SUBSCRIPTION_ID=$(ARM_SUBSCRIPTION_ID)
                
                terraform init -input=false -upgrade
                terraform apply -auto-approve -input=false
                
                echo "Fetching output variables..."
                RG_NAME=$(terraform output -raw resource_group_name)
                ACR_LOGIN_SERVER=$(terraform output -raw container_registry_login_server)
                ACR_ADMIN_USER=$(terraform output -raw acr_admin_username)
                ACR_ADMIN_PASS=$(terraform output -raw acr_admin_password)
                COSMOS_DB_CONN_STRING=$(terraform output -raw cosmos_db_connection_string)
                
                echo "##vso[task.setvariable variable=RG_NAME;isOutput=true]$RG_NAME"
                echo "##vso[task.setvariable variable=ACR_LOGIN_SERVER;isOutput=true]$ACR_LOGIN_SERVER"
                echo "##vso[task.setvariable variable=ACR_ADMIN_USER;isOutput=true]$ACR_ADMIN_USER"
                echo "##vso[task.setvariable variable=ACR_ADMIN_PASS;isOutput=true]$ACR_ADMIN_PASS"
                echo "##vso[task.setvariable variable=COSMOS_DB_CONN_STRING;isOutput=true]$COSMOS_DB_CONN_STRING"
            env:
              ARM_CLIENT_ID: $(ARM_CLIENT_ID)
              ARM_CLIENT_SECRET: $(ARM_CLIENT_SECRET)
              ARM_TENANT_ID: $(ARM_TENANT_ID)
              ARM_SUBSCRIPTION_ID: $(ARM_SUBSCRIPTION_ID)

  # ==========================================================
  # 2Ô∏è‚É£ Stage: Build & Push Docker Images
  # ==========================================================
  - stage: Build
    displayName: '2. Build & Push Docker Images'
    dependsOn: Infra
    condition: succeeded('Infra')
    jobs:
      - job: BuildAndPush
        displayName: 'Build & Push All Services'
        pool:
          vmImage: $(vmImage)
        steps:
          - checkout: self

          - task: Maven@3
            displayName: 'Build All Java Modules'
            inputs:
              mavenPomFile: 'pom.xml'
              goals: 'package'
              options: '-DskipTests'
              jdkVersionOption: '1.17'

          # Build each service in loop
          - ${{ each service in split(variables.microservice_list, ',') }}:
              - task: Docker@2
                displayName: 'Build & Push: ${{ service }}'
                inputs:
                  command: 'buildAndPush'
                  containerRegistry: $(acrServiceConnection)
                  repository: '${{ service }}'
                  dockerfile: 'Mesh-Microservices/${{ service }}/Dockerfile'
                  buildContext: 'Mesh-Microservices/${{ service }}'
                  tags: |
                    $(docker_tag)
                    latest

  # ==========================================================
  # 3Ô∏è‚É£ Stage: Deploy Containers to WebApps
  # ==========================================================
  - stage: Deploy
    displayName: '3. Deploy Containers to WebApps'
    dependsOn:
      - Infra
      - Build
    condition: succeeded('Build')
    jobs:
      - job: DeployJob
        displayName: 'Deploy All Microservices'
        pool:
          vmImage: $(vmImage)
        variables:
          RG_NAME: $[ stageDependencies.Infra.TerraformApply.outputs['TerraformApply.RG_NAME'] ]
          ACR_LOGIN_SERVER: $[ stageDependencies.Infra.TerraformApply.outputs['TerraformApply.ACR_LOGIN_SERVER'] ]
          ACR_ADMIN_USER: $[ stageDependencies.Infra.TerraformApply.outputs['TerraformApply.ACR_ADMIN_USER'] ]
          ACR_ADMIN_PASS: $[ stageDependencies.Infra.TerraformApply.outputs['TerraformApply.ACR_ADMIN_PASS'] ]
          COSMOS_DB_CONN_STRING: $[ stageDependencies.Infra.TerraformApply.outputs['TerraformApply.COSMOS_DB_CONN_STRING'] ]
        steps:
          - ${{ each service in split(variables.microservice_list, ',') }}:
              - task: AzureCLI@2
                displayName: 'Deploy: ${{ service }}'
                inputs:
                  azureSubscription: $(azureServiceConnection)
                  scriptType: bash
                  scriptLocation: inlineScript
                  inlineScript: |
                    set -e
                    APP_NAME="${{ service }}-webapp"
                    IMAGE_NAME="$(ACR_LOGIN_SERVER)/${{ service }}:$(docker_tag)"
                    
                    echo "üöÄ Deploying $APP_NAME with image $IMAGE_NAME"
                    
                    az webapp config container set \
                      --name "$APP_NAME" \
                      --resource-group "$(RG_NAME)" \
                      --docker-custom-image-name "$IMAGE_NAME" \
                      --docker-registry-server-url "https://$(ACR_LOGIN_SERVER)" \
                      --docker-registry-server-user "$(ACR_ADMIN_USER)" \
                      --docker-registry-server-password "$(ACR_ADMIN_PASS)"
                    
                    echo "üîß Updating App Settings for $APP_NAME"
                    SETTINGS=( \
                      "WEBSITES_PORT=8080" \
                      "SPRING_DATA_MONGODB_URI=$(COSMOS_DB_CONN_STRING)" \
                    )
                    
                    if [ "${{ service }}" != "discovery-server" ]; then
                      SETTINGS+=("EUREKA_CLIENT_SERVICEURL_DEFAULTZONE=http://discovery-server-webapp.azurewebsites.net/eureka/")
                    else
                      SETTINGS+=("EUREKA_CLIENT_REGISTERWITHEUREKA=false" "EUREKA_CLIENT_FETCHREGISTRY=false")
                    fi
                    
                    if [ "${{ service }}" == "ai-service" ]; then
                      SETTINGS+=("GEMINI_API_KEY=$(GEMINI_API_KEY)")
                    fi
                    
                    az webapp config appsettings set \
                      --resource-group "$(RG_NAME)" \
                      --name "$APP_NAME" \
                      --settings "${SETTINGS[@]}"
